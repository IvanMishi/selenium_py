# Прокрутка в область видимости элемента с помощью метода .execute_script

## Инженер по тестированию переходит в директорию, предназначенную для хранения файлов с тестами
```
cd selenium_tests
```
## Из директории selenium_tests активирует виртуальное окружение
```sh
source selenium_env/bin/activate
```
## В активированном окружении запускает тест 
```sh
python3 test_10(execute_script)/test_A.py
```
## Для вывода результата в отдельный файл зпускает командой 
```sh
python3 test_10(execute_script)/test_A.py >> test_10(execute_script)/output.txt
```
Где test_A.py -  скрипт с тестом, а output.txt - файл, в который будет записан вывод теста.

## Скроллинг по координатам
```driver.execute_script("window.scrollTo(x, y);")```
x - это количество пикселей, на которое необходимо сместиться по горизонтали, то есть влево-вправо
y - это количество пикселей, на которое необходимо сместиться по вертикали, то есть вверх-вниз

Например, данная команда прокручивает страницу на 100 пикселей вниз x = 0 - это левый верхний угол, y = 100 это 100px от верхнего левого угла вниз, задаются  абсолютные координаты для прокрутки страницы.\
```driver.execute_script("window.scrollTo(0, 100);")```
Смещение прокрутки относительно текущего положения страница будет прокручена вниз на 100 пикселей от текущего положения. \
Если вы уже находитесь на 50 пикселях от верхней части страницы, использование scrollBy переместит вас на 150 пикселей от верхней части.
```driver.execute_script("window.scrollBy(0, 100);")``` 
Для того, чтобы вернуться в самый верх экрана, на исходную позицию
```driver.execute_script("window.scrollTo(0, 0);")```



## Тестовые данные test_A
- [x] Незарегестированный пользователь переходит по ссылке
- [x] Cчитывает данные для переменной x из элемента на веб странице.
- [x] Считает математическую функцию от x и вводит ответ в текстовое поле.
- [x] Прокручивает страницу вниз для отображения кнопки
- [x] Отмечает чекбокс "I'm the robot".
- [x] Переключает радиокнопку "Robots rule!".
- [x] Нажимает на кнопку "Submit".
#### В программе использует прокрутку страницы до элемента, чтобы он был виден:\
Для выполнения JavaScript-кода на странице и обеспечения видимости элементов, скрытых футером, используется метод: \
```webdriver.execute_script("return arguments[0].scrollIntoView(true);", button_submit)``` 
Этот скрипт прокручивает страницу, чтобы элемент стал видимым. \
WebDriver также проверяет, что ширина и высота элемента больше нуля, что гарантирует его кликабельность. 
Однако даже при видимости элемент может быть перекрыт другим, что приведет к ошибке при попытке клика.\
Такой подход обеспечивает видимость элемента, но не исключает возможность его перекрытия.\
В случае перекрытия возникает ошибка, например:\
```selenium.common.exceptions.WebDriverException: Message: unknown error: Element <button type="submit" class="btn btn-default" style="margin-bottom: 1000px;">...</button> is not clickable at point (87, 420). Other element would receive the click: <p>...</p>```\



## Тестовые данные test_B
- [x] Незарегестированный пользователь переходит по ссылке
- [x] Прокручивает к каждому чекбоксу и отмечает его.
- [x] После отметки чекбокса добавляет в список число, если появляется рядом с ним.
- [x] Суммирует полученные значения и выводит результат в консоль.
#### В программе использует прокрутку страницы до элемента, чтобы он был виден:\
Программа использует цикл for для итерации по 100 чекбоксам. \
Cтраница прокручивается вниз к чекбоксу с помощью следующего кода:
```webdriver.execute_script("return arguments[0].scrollIntoView(true);", checkbox) ```
```checkbox.click()``` # Для каждого чекбокса к которому выполнен скролл выполняется клик



## Тестовые данные test_C
- [x] Незарегестированный пользователь переходит по ссылке
- [x] Создает список для необработаных элементов типа чекбокс
- [x] Прокручивает к каждому чекбоксу и отмечает его, обавляет в список, пока не выберет 40 чекбоксов.
- [x] После отметки 40 чекбоксов программа выолнена.
#### В программе использует:
Если известно количество элементов которые нужно обработать, то можно использовать следующий код:\
Создает пустой список для хранения входных данных\
```list_input = []```\
Запускает бесконечный цикл\
```while True:```\
Если длина списка равна 40, выходим из цикла, программа выполнена\
```if len(list_input) == 40:```\
```            break```


## Тестовые данные test_D
- [x] Незарегестированный пользователь переходит по ссылке
- [x] Отмечает все нечетные чекбоксы
- [x] Нажимает появившуюся кнопку для вызова алерта
- [x] Выводит сообщение из алерата в консоль 
#### В программе использует:\
Если необходимо обработать первые 100 элементов, то можно использовать следующий код, для того чтобы сначала прокрутить до последнего элемента и подгрузить в dom:\
```while len(webdriver.find_elements(By.CSS_SELECTOR, "input")) < 1000:```
```last = webdriver.find_element(By.CSS_SELECTOR, ".child_container:last-child")```
```webdriver.execute_script("return arguments[0].scrollIntoView(true)", last)```
 Затем после того как элменты добавлены в dom, можно взаимодействовать с ними.


## Тестовые данные test_E
- [x] Незарегестированный пользователь переходит по ссылке
- [x] Нажимает на кнопку на странице  
- [x] При нажатии появляется числовое значение в верхней области страницы
- [x] Считает сумму всех найденых значений после нажатия на каждую кнопку на странице 
#### В программе использует прокрутку страницы до элемента, чтобы он был виден:\
Прокручвает страницу в цикле for к кажому элементу\
```for element in buttons:```
```        webdriver.execute_script("return arguments[0].scrollIntoView(true);", element)```


## Тестовые данные test_F
- [x] Незарегестированный пользователь переходит по ссылке
- [x] Нажимает на кнопки разбросанные на странице
- [x] При достижении лимита нажатых кнопок появляется алерт из которого выводит текст в качестве ответа в консоль
- [x] Выводит количество обработанных кнопок в консоль
#### В программе использует прокрутку страницы до элемента, чтобы он был виден:\
'каскадный поиск'
Ищет родительский элемент - контейнер с кнопками, затем в цикле прокручивает к каждому дочернему и выполняет действия с ним\
```parrent = webdriver.find_elements(By.CSS_SELECTOR, "[class='button-container']")```
```    for element in parrent:```
```        webdriver.execute_script("return arguments[0].scrollIntoView(true);", element)```
```        element.click()```
```        count += 1```


## Тестовые данные test_G
- [x] Незарегестированный пользователь переходит по ссылке
- [x] Находит кнопки для отметки 'Like' на странице
- [x] При отметке найденой кнопки суммирует появившиеся свзанные значения
- [x] Если новых кнопок на странице не найдено, выводит полученную сумму в качестве ответа в консоль
#### В программе использует прокрутку страницы до элемента, чтобы он был виден до тех пор пока появляются новые элементы:\
```while True:```  # Начинает бесконечный цикл для постоянной обработки кнопок.
```    new_buttons_found = False```  # Флаг, указывает, были ли найдены новые кнопки за итерацию.
```    new_buttons_found = True```  # Обновляет флаг, так как нашли новую кнопку.
```    if not new_buttons_found:```  # Если флаг new_buttons_found остается False, значит, новые кнопки не найдены.
```        break```  # Выходим из бесконечного цикла.