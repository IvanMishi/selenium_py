# Неявное ожидание(Implicit waits)  

## Инженер по тестированию переходит в директорию, предназначенную для хранения файлов с тестами
```
cd selenium_tests
```
## Из директории selenium_tests активирует виртуальное окружение
```sh
source selenium_env/bin/activate
```
## В активированном окружении запускает тест 
```sh
python3 test_(waits)/test_A.py
```
## Для вывода результата в отдельный файл зпускает командой 
```sh
python3 test_(waits)/test_A.py >> test_(waits)/output.txt
```
Где test_A.py -  скрипт с тестом, а output.txt - файл, в который будет записан вывод теста.


## Ожидание окон, элементов и алертов
WebDriverWait(browser).until(EC.ожидаемое условие((locator)))
Если метод работает с одним элементом → он возвращает WebElement
Если метод работает с несколькими элементами → он возвращает list[WebElement]


```EC.frame_to_be_available_and_switch_to_it(locator)```\
Это ожидаемое условие, проверяет доступность iframe на веб-странице и автоматически переключается на него. 
Локатор представляет собой кортеж, содержащий метод поиска (например, By.ID или By.XPATH) и соответствующее значение.
Множество сайтов применяют фреймы для разделения контента или вставки внешних элементов, таких как капчи. 
Для взаимодействия с содержимым внутри фрейма необходимо сперва переключиться на него. 

Данное условие ищет фрейм по указанному локатору и, если он доступен, выполняет переключение.
locator = (By.ID, 'iframe_id')
WebDriverWait(browser, 10).until(EC.frame_to_be_available_and_switch_to_it(locator))




```EC.element_to_be_selected(element)```
Это ожидаемое условие проверяет, выбран ли указанный элемент на веб-странице, чаще всего в формах, таких как чекбоксы, радиокнопки или элементы выпадающего списка. 
Когда элемент передается в это условие, Selenium проверяет его атрибут selected. 
Если элемент выбран (атрибут присутствует и установлен в true), условие считается выполненным.

Находим элемент (чекбокс) на странице
checkbox_element = browser.find_element(By.ID, "my_checkbox")
Используем явное ожидание, чтобы убедиться, что чекбокс выбран
WebDriverWait(browser, 10).until(EC.element_to_be_selected(checkbox_element))


```EC.element_located_to_be_selected(locator)```
Это ожидаемое условие проверяет, выбран ли элемент, определяемый по локатору, который может быть чекбоксом, радиокнопкой или опцией в выпадающем списке. 
Локатор представляет собой кортеж из двух элементов: стратегии поиска (например, By.ID, By.XPATH) и самого запроса для поиска.

Selenium сначала ищет элемент на странице по указанному локатору. 
checkbox_locator = (By.ID, 'accept_terms_checkbox')
Если элемент найден, проверяется его атрибут selected.
WebDriverWait(browser, 10).until(EC.element_located_to_be_selected(checkbox_locator)) 
Если элемент выбран (чекбокс отмечен, радиокнопка активна, опция в выпадающем списке выбрана), возвращается True, иначе - False. 
В случае, если элемент не выбран, Selenium будет ожидать до истечения таймаута, периодически повторяя попытки проверки. 
Если время ожидания истечет, а элемент так и не станет выбранным, будет выброшено исключение TimeoutException.


```EC.element_selection_state_to_be(element, is_selected)```
Это ожидаемое условие, проверяющее, соответствует ли состояние выбора элемента ожидаемому значению. 
Элемент может быть чекбоксом, радио кнопкой или любым другим элементом формы с атрибутом selected. 
Булево значение is_selected указывает, ожидается ли, что элемент будет выбран. 

Например, на веб-странице с формой необходимо подтвердить, что определенный чекбокс отмечен или, наоборот, не отмечен. 
checkbox = browser.find_element(By.ID, 'my_checkbox')
Условие позволяет дождаться изменения состояния выбора элемента до его соответствия значению is_selected или до истечения времени ожидания.
WebDriverWait(browser, 10).until(EC.element_selection_state_to_be(checkbox, True))


```EC.element_located_selection_state_to_be(locator, is_selected)```
Это ожидаемое условие, которое проверяет, находится ли элемент, определяемый локатором, в состоянии выбора (выбран или не выбран). 
Локатор представляет собой кортеж с методом поиска и значением, например, (By.ID, 'checkbox'). 
Булево значение is_selected указывает ожидаемое состояние: True — элемент должен быть выбран, False — не должен.

Selenium сначала ищет локатор на веб-странице, используя предоставленный локатор. 
locator = (By.ID, 'my_checkbox')
Затем ожидаемое условие проверяет, находится ли найденный локатор в ожидаемом состоянии: True (элемент выбран) или False (не выбран). 
expected_state = True  # Ожидаем, что чекбокс будет отмечен
Если состояние элемента соответствует ожидаемому, возвращается True, и программа продолжает выполнение. 
WebDriverWait(browser, 10).until(EC.element_located_selection_state_to_be(locator, True)) # Ожидаем, пока чекбокс не окажется в ожидаемом состоянии
В противном случае происходит ожидание до истечения времени, после чего, в случае неудачи, выбрасывается исключение TimeoutException.













## Тестовые данные test_A
- [x] Незарегестированный пользователь переходит по ссылке
- [x] Ждет когда кнопка станет кликбельной
- [x] После успешного нажатия на кнопку ожидает полного совпадения заголовка, если заголовок совпадает выводит текст из элемента с id='result' в консоль\
#### В программе использует явные ожидания: 

```.invisibility_of_element()```
Это ожидаемое условие, проверки, что элемент уже найден, и мы хотим проверить, стал ли он невидимым. \
Поиск элемента с помощью условия EC.invisibility_of_element() отличается от других ожидаемых условий, так как не выполняет поиск элемента на странице. 
Он предполагает, что элемент уже найден и передан в качестве аргумента. 
Это означает, что предварительно необходимо найти элемент.
element = browser.find_element(By.ID,'popup')
Условие проверяет видимость элемента на странице. 
WebDriverWait(browser, 10).until(EC.invisibility_of_element(element)) # Ждем, пока всплывающее окно исчезнет
Элемент считается невидимым, если он отсутствует в DOM, имеет ширину и высоту равные нулю, или у него задан стиль display: none.
В зависимости от состояния элемента, условие возвращает резульаты: если элемент невидим, возвращается True, если видим — False. 


## Тестовые данные test_B
- [x] Незарегестированный пользователь переходит по ссылке
- [x] Ждет когда кнопка станет кликбельной
- [x] После успешного нажатия на кнопку ожидает полного совпадения заголовка, если заголовок совпадает выводит текст из элемента с id='result' в консоль\
#### В программе использует явные ожидания: 

```EC.staleness_of(element)```
Это ожидаемое условие, которое проверяет, стал ли элемент устаревшим, то есть исчез ли он из DOM-структуры страницы или был перезагружен. 
Оно возвращает True, если элемент больше не присутствует в DOM или его состояние изменилось. 
Элемент — это объект веб-страницы, который ожидается как устаревший.
При взаимодействии с веб-страницей Selenium сохраняет ссылки на элементы. 
Если страница обновляется или элементы исчезают, ранее найденные ссылки могут стать недействительными. 
Условие staleness_of проверяет действительность ссылки на элемент, и если он исчез из DOM или его состояние поменялось, возвращает True. 
Это полезно для ожидания завершения асинхронных операций на странице, которые могут влиять на DOM.

Находим элемент
element = browser.find_element(By.ID, 'some_element')
Выполняем действие, которое приведет к обновлению элемента (например, клик по кнопке)
browser.find_element_by_id('update_button').click()
Ожидаем, пока элемент станет устаревшим
WebDriverWait(browser, 10).until(EC.staleness_of(element))

Дополнение:
Устаревание (staleness) в Selenium происходит, когда элемент теряет связь с текущим DOM или его ссылка становится недействительной. 
Это может случиться, если элемент удаляется из DOM, заменяется другим элементом или если страница перезагружается, в результате чего весь DOM обновляется. 
Метод EC.staleness_of(element) возвращает значение True только в том случае, если сохраненная ссылка на элемент (WebElement) становится неактуальной в текущем состоянии страницы.

## Тестовые данные test_C
- [x] Незарегестированный пользователь переходит по ссылке
- [x] Ждет когда кнопка станет кликбельной
- [x] После успешного нажатия на кнопку ожидает полного совпадения заголовка, если заголовок совпадает выводит текст из элемента с id='result' в консоль\

```EC.number_of_windows_to_be(num_windows)```
Это ожидаемое условие, которое проверяет, соответствует ли текущее количество открытых окон в браузере заданному числу. 

Selenium позволяет взаимодействовать с несколькими окнами и вкладками, отслеживая все открытые элементы. 
num_windows_before = len(browser.window_handles) # Предполагаем, что изначально открыто одно окно
browser.find_element(By.ID, 'some_link').click() # Выполняем действие, которое должно открыть новое окно

Условие EC.number_of_windows_to_be принимает это число и сравнивает его с переданным параметром num_windows. 
Если текущее количество открытых окон совпадает с ожидаемым, условие возвращает True, подтверждая успешное выполнение. 
В противном случае ожидание продолжается до истечения тайм-аута, после чего возвращается False.
WebDriverWait(browser, 10).until(EC.number_of_windows_to_be(num_windows_before + 1)) # Ожидаем, пока не откроется новое окно
С помощью специальной функции можно получить список дескрипторов окон, где каждый дескриптор представляет собой уникальный идентификатор. 
new_window_handle = [handle for handle in browser.window_handles if handle != browser.current_window_handle][0] # Теперь можно безопасно переключиться на новое окно и продолжить тест
browser.switch_to.window(new_window_handle)


```EC.new_window_is_opened(current_handles)```
Это ожидаемое условие, которое проверяет, было ли открыто новое окно или вкладка браузера.

Список current_handles представляет собой уникальные идентификаторы уже открытых окон и вкладок. 
current_handles = browser.window_handles # Получаем список текущих открытых окон/вкладок
В автоматизации тестирования или парсинга веб-страниц часто возникают ситуации, когда в результате действий, таких как клик по ссылке или кнопке, открывается новое окно или вкладка. 
browser.find_element(By.ID, 'open_new_window_button').click() # Выполняем действие, которое должно открыть новое окно/вкладку
Чтобы продолжить работу с этим новым окном, необходимо подтвердить его открытие.
WebDriverWait(browser, 10).until(EC.new_window_is_opened(current_handles))# Ждем открытия нового окна/вкладки
При выполнении этого условия Selenium сравнивает актуальный список открытых окон с текущим списком current_handles. 
new_handles = browser.window_handles # Получаем новый список окон/вкладок
new_window = [handle for handle in new_handles if handle not in current_handles][0] # Находим идентификатор нового окна/вкладки
browser.switch_to.window(new_window) # Переключаемся на новое окно/вкладку
Если количество окон увеличивается и появляется хотя бы один уникальный идентификатор, условие считается выполняемым.

```EC.alert_is_present()```
Это ожидаемое условие  предназначено для проверки наличия всплывающего окна предупреждения (alert) на веб-странице. 

Это окно не является частью DOM-дерева, поэтому для его обработки требуются специальные методы WebDriver. 
При вызове EC.alert_is_present() WebDriver ищет всплывающее окно на текущей странице. 
alert = WebDriverWait(browser, 10).until(EC.alert_is_present())
Если оно найдено, функция возвращает объект Alert, с которым можно взаимодействовать, например, принять или отклонить его, а также извлечь текст. 
text = alert.text
alert.accept()
В случае отсутствия всплывающего окна выбрасывается исключение NoAlertPresentException.