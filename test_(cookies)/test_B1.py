import time  # Модуль для работы с функцией ожидания
from selenium import webdriver  # Модуль для взаимодействия с веб-браузерами
from selenium.webdriver.common.by import By  # Модуль для определения способов поиска элементов на странице
import json # Модуль для преобразования в формат json
import re # Модуль для работы с регулярными выражениями

# Ссылка на страницу.
link = 'https://parsinger.ru/selenium/5.6/1/index.html'
# Измеряет время выполнения.
start = time.time()
# Чтение куки из текстового файла.
with open('cookie_dict.txt', 'r') as file:  # Открывает текстовый файл для чтения
    cookie_dict = json.load(file)  # Читает и загружает куки как список словарей


with webdriver.Chrome() as driver:  # Создаёт экземпляр драйвера Chrome и автоматически закрывает его по завершении блока кода.
    driver.get(link)  # Переходит по ссылке.
    time.sleep(1)  # Убеждается что открыта искомая страница.
    # Ошибка будет выведена в консоль в случае если URL не совпадают.
    assert link == driver.current_url, f'\nОжидаемый   URL: {link}, \nФактический URL: {driver.current_url}'


    print('Инициализация пустого списка для хранения результатов обработки кандидатов')
    result = []
    print('Цикл для добавления всех куки из словаря cookie_dict')
    for cookie in cookie_dict:
        print('Добавляет куки в текущую сессию браузера')
        driver.add_cookie(cookie)
        print('Обновляет страницу, чтобы изменения куки вступили в силу')
        driver.refresh()

        print('Получает значение куки кандидата')
        for skill in driver.get_cookies(): # Извлекает все куки, доступные на странице
            val_cookie = skill['value']  # Берет последнее значение куки

        print('Получает возраст в числовом знаении.')
        age = driver.find_element(By.ID, "age").text # Получение возраста кандидата из элемента с ID "age"
        print('Проверка наличия числовых значений в строке age.')
        match = re.search(r'\d+', age) # Ищет последовательность цифр в строке возраста
        if match:
            age_value = int(match.group())  # Преобразует найденное значение в целое число
        else:
            print(f'Возраст не найден или имеет неверный формат у кандидата с значением куки:.{val_cookie}')  # Выводит сообщение об ошибке

        # Получает список навыков.
        print('Находит все элементы списка навыков.')
        skill_list = driver.find_elements(By.CSS_SELECTOR, "#skillsList > li")
        print('Получает количество навыков.')
        num_skills = len(skill_list) # Считает количество найденных элементов списка навыков
        print('Добавляет результаты в список в виде кортежа: (возраст, количество навыков, куки)')
        result.append((age_value, num_skills, val_cookie))
        print('Удаляет все куки перед следующим циклом, чтобы избежать конфликтов между данными кандидатов')
        driver.delete_all_cookies()
        print('Выводит в консоль данные о кандидатах для отладки')
        print(f'Возраст:{age_value} Количество навыков: {num_skills} Значение куки: {val_cookie}')

print('Находит кандидата с максимальным возрастом и максимальным количеством навыков в случае равенства возраста')
# Используем функцию max() с параметром key, который представляет собой лямбда-выражение.
# Оно возвращает кортеж (-x[0], x[1]), где x[0] — это возраст кандидата, а x[1] — количество навыков.
# Мы используем отрицательное значение возраста (-x[0]), чтобы найти кандидата с минимальным возрастом,
# а если есть равные возраста, то выбираем кандидата с наибольшим количеством навыков (x[1]).
candidat_find = max(result, key=lambda x: (-x[0], x[1]))

print('Выводит информацию о самом молодом кандидате с наибольшим количеством навыков')
print(f'Самый молодой кандидат имеет возраст: {candidat_find[0]} и наиболшее количество навыков в возрастной категории: {candidat_find[1]} Значение его куки: {candidat_find[2]}')


# Завершение отсчета времени
end = time.time()
print(f"Время выполнения: {end - start} секунд.")
